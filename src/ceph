#!/usr/bin/python

import sys
import os
import stat
#import rados
import json
import copy
import types
import subprocess
import socket
import uuid
import argparse
import select
import fcntl

"""
Something wrong with arguments
"""
class ArgumentError(Exception):
    pass

"""
Wrong number of a repeated argument
"""
class ArgumentNumber(ArgumentError):
    pass

"""
Argument value has wrong format 
"""
class ArgumentFormat(ArgumentError):
    pass

"""
Argument value is otherwise invalid (doesn't match choices, for instance)
"""
class ArgumentValid(ArgumentError):
    pass

"""
Special for mismatched prefix; less severe, don't report by default
"""
class ArgumentPrefix(ArgumentError):
    pass

"""
some semantic issue with the JSON
"""
class JsonFormat(Exception):
    pass

"""
Base class for all Ceph argument types

Instantiating an object sets any validation parameters 
(allowable strings, numeric ranges, etc.).  The 'valid'
method validates a string against that initialized instance,
throwing ArgumentError if there's a problem.
"""
class CephArgtype(object):
    def __init__(self, **kwargs):
        """
        set any per-instance validation parameters here 
        from kwargs (fixed string sets, integer ranges, etc)
        """
        pass

    def valid(self, s, partial=False):
        """
        Run validation against given string s (generally one word);
        partial means to accept partial string matches (begins-with).
        If cool, set self.val to the value that should be returned
        (a copy of the input string, or a numeric or boolean interpretation
        thereof, for example), and return True
        if not, throw ArgumentError(msg-as-to-why)
        """
        pass

    def __repr__(self):
        """
        return string representation of description of type.  Note,
        this is not a representation of the actual value.  Subclasses
        probably also override __str__() to give a more user-friendly
        'name/type' description for use in command format help messages.
        """
        a = ''
        if hasattr(self, 'typeargs'):
            a = self.typeargs
        return '{}(\'{}\')'.format(self.__class__.__name__, a)

    def __str__(self):
        """
        where __repr__ (ideally) returns a string that could be used to
        reproduce the object, __str__ returns one you'd like to see in
        print messages.  Use __str__ to format the argtype descriptor
        as it would be useful in a command usage message.
        """
        return '<{}>'.format(self.__class__.__name__)

"""
range-limited integers, [+|-][0-9]+ or 0x[0-9a-f]+
range: list of 1 or 2 ints, [min] or [min,max]
"""
class CephInt(CephArgtype):
    def __init__(self, range=''):
        if range == '':
            self.range = list()
        else:
            self.range = list(range.split('|'))
            self.range = map(long, self.range)

    def valid(self, s, partial=False):
        try:
            val = long(s)
        except ValueError:
            raise ArgumentValid("{} doesn't represent an int".format(s))
        if len(self.range) == 2:
            if val < self.range[0] or val > self.range[1]:
                raise ArgumentValid("{} not in range {}".format(val, self.range))
        elif len(self.range) == 1:
            if val < self.range[0]:
                raise ArgumentValid("{} not in range {}".format(val, self.range))
        self.val = val
        return True

    def __str__(self):
        r = ''
        if len(self.range) == 1:
            r = '[{}-]'.format(self.range[0])
        if len(self.range) == 2:
            r = '[{}-{}]'.format(self.range[0], self.range[1])

        return '<int{}>'.format(r)


"""
range-limited float type
range: list of 1 or 2 floats, [min] or [min, max]
"""
class CephFloat(CephArgtype):
    def __init__(self, range=''):
        if range == '':
            self.range = list()
        else:
            self.range = list(range.split('|'))
            self.range = map(float, self.range)

    def valid(self, s, partial=False):
        try:
            val = float(s)
        except ValueError:
            raise ArgumentValid("{} doesn't represent a float".format(s))
        if len(self.range) == 2:
            if val < self.range[0] or val > self.range[1]:
                raise ArgumentValid("{} not in range {}".format(val, self.range))
        elif len(self.range) == 1:
            if val < self.range[0]:
                raise ArgumentValid("{} not in range {}".format(val, self.range))
        self.val = val
        return True

    def __str__(self):
        r = ''
        if len(self.range) == 1:
            r = '[{}-]'.format(self.range[0])
        if len(self.range) == 2:
            r = '[{}-{}]'.format(self.range[0], self.range[1])
        return '<float{}>'.format(r)

"""
String.  Not much use for this; maybe we might use illegal chars
for something?
"""
class CephString(CephArgtype):
    def __init__(self, badchars=''):
        self.badchars = badchars

    def valid(self, s, partial=False):
        for c in self.badchars:
            if c in s:
                raise ArgumentFormat("bad char {} in {}".format(c, s))
        self.val = s
        return True

    def __str__(self):
        b = ''
        if len(self.badchars):
            b = '(without chars in {})'.format(self.badchars)
        return '<string{}>'.format(b)

"""
Admin socket path; check that it's readable and S_ISSOCK
"""
class CephSocketpath(CephArgtype):
    def valid(self, s, partial=False):
        mode = os.stat(s).st_mode
        if not stat.S_ISSOCK(mode):
            raise ArgumentValid('socket path {} is not a socket'.format(s))
        self.val = s
        return True
    def __str__(self):
        return '<admin-socket-path>'

"""
IP address (v4 or v6) with optional port
"""
class CephIPAddr(CephArgtype):
    def valid(self, s, partial=False):
        # parse off port, use socket to validate addr
        type = 6
        if s.startswith('['):
            type = 6
        elif s.find('.') != -1:
            type = 4
        if type == 4:
            port = s.find(':')
            if (port != -1):
                a = s[:port]
                p = s[port+1:]
                if int(p) > 65535:
                    raise ArgumentValid('{}: invalid IPv4 port'.format(p))
            else:
                a = s
                p = None
            try:
                socket.inet_pton(socket.AF_INET, a)
            except:
                raise ArgumentValid('{}: invalid IPv4 address'.format(a))
        else:
            # v6
            if s.startswith('['):
                end = s.find(']')
                if end == -1:
                    raise ArgumentFormat('{} missing terminating ]'.format(s))
                if s[end+1] == ':':
                    try:
                        p = int(s[end+2])
                    except:
                        raise ArgumentValid('{}: bad port number'.format(s))
                a = s[1:end]
            else:
                a = s
                p = None
            try:
                socket.inet_pton(socket.AF_INET6, a)
            except:
                raise ArgumentValid('{} not valid IPv6 address'.format(s))
        if p is not None and long(p) > 65535:
            raise ArgumentValid("{} not a valid port number".format(p))
        self.val = s
        return True

    def __str__(self):
        return '<IPaddr[:port]>' 

class CephEntityAddr(CephIPAddr):
    def valid(self, s, partial=False):
        ip, nonce = s.split('/')
        if not super(CephIPAddr, self).valid(self, ip):
            raise ArgumentValid('CephEntityAddr {}: ip address invalid'.format(s))
        self.val = s
        return True

    def __str__(self):
        return '<EntityAddr>'

"""
Pool name; checked for presence in cluster
"""
class CephPoolname(CephArgtype):
    def valid(self, s, partial=False):
        # if cluster.pool.exists(s):
        #    raise ArgumentValid("pool {} does not exist".format(s))
        self.val = s
        return True

    def __str__(self):
        return '<poolname>'

"""
Object name.  Maybe should be combined with Pool name as they're always
present in pairs, and then could be checked for presence
"""
class CephObjectname(CephArgtype):
    def valid(self, s, partial=False):
        self.val = s
        return True

    def __str__(self):
        return '<objectname>'

"""
pgid, in form N.xxx (N = pool number, xxx = hex pgnum)
"""
class CephPgid(CephArgtype):
    def valid(self, s, partial=False):
        if s.find('.') == -1:
            raise ArgumentFormat('pgid has no .')
        poolid, pgnum = s.split('.')
        try:
            pgnum = int(pgnum, 16)
        except:
            raise ArgumentFormat('pgnum {} not hex integer'.format(pgnum))
        self.val = s
        return True

    def __str__(self):
        return '<pgid>'

"""
Name, or type.id, where type is osd|mon|client|mds, and id is a base10 int.
Also accept '*'
"""
class CephName(CephArgtype):
    def valid(self, s, partial=False):
        if s == '*':
            self.val = s
            return True
        if s.find('.') == -1:
            raise ArgumentFormat('no .')
        t, i = s.split('.')
        if not t in ('osd', 'mon', 'client', 'mds'):
            raise ArgumentValid('unknown type ' + self.t)
        if t == 'osd':
            try:
                i = int(i)
            except:
                raise ArgumentFormat('osd id ' + i + ' not integer')
            # could check for valid id?
        self.val = s
        return True

    def __str__(self):
        return '<name (type.id)>'

"""
Set of string literals; init with valid choices
"""

class CephChoices(CephArgtype):
    def __init__(self, strings='', **kwargs):
        self.strings=strings.split('|')

    def valid(self, s, partial=False):
        if not partial:
            if not s in self.strings:
                # show as __str__ does: {s1|s2..}
                raise ArgumentValid("{} not in {}".format(s, self))
            self.val = s
            return True

        # partial
        for t in self.strings:
            if t.startswith(s):
                self.val = s
                return True
        raise ArgumentValid("{} not in {}".  format(s, self))

    def __str__(self):
        if len(self.strings) == 1:
            return '{}'.format(self.strings[0])
        else:
            return '{{{}}}'.format('|'.join(self.strings))

"""
Openable file
"""
class CephFilepath(CephArgtype):
    def valid(self, s, partial=False):
        try:
            open(s, 'a+')
        except Exception as e:
            raise ArgumentValid('can\'t open {}: {}'.format(s, e))
        self.val = s
        return True

    def __str__(self):
        return '<outfilename>'

"""
'Fragment' ??? XXX
"""
class CephFragment(CephArgtype):
    def valid(self, s, partial=False):
        if s.find('/') == -1:
            raise ArgumentFormat('{}: no /'.format(s))
        val, bits = s.split('/')
        # XXX is this right?
        if not val.startswith('0x'):
            raise ArgumentFormat("{} not a hex integer".format(val))
        try:
            long(val)
        except:
            raise ArgumentFormat('can\'t convert {} to integer'.format(val))
        try:
            long(bits)
        except:
            raise ArgumentFormat('can\'t convert {} to integer'.format(bits))
        self.val = s
        return True

    def __str__(self):
        return "<CephFS fragment ID (0xvvv/bbb)>"


""" 
CephUUID: pretty self-explanatory
"""
class CephUUID(CephArgtype):
    def valid(self, s, partial=False):
        try:
            uuid.UUID(s)
        except Exception as e:
            raise ArgumentFormat('invalid UUID {}: {}'.format(s, e))
        self.val = s
        return True

    def __str__(self):
        return '<uuid>'

"""
CephPrefix: magic type for "all the first n fixed strings"
"""
class CephPrefix(CephArgtype):
    def __init__(self, prefix=''):
        self.prefix = prefix

    def valid(self, s, partial=False):
        if partial:
            if self.prefix.startswith(s):
                self.val = s
                return True
        else:
            if (s == self.prefix):
                self.val = s
                return True
        raise ArgumentPrefix("no match for {}".format(s))

    def __str__(self):
        return self.prefix

############################################################################

# argdesc(typename, [type-specific kwargs], name='name', n=numallowed, req=False, helptext=helptext, **kwargs)
# validation rules:
# typename: type(**kwargs) will be constructed
# later, type.valid(w) will be called with a word in that position
# name is used for parse errors and for constructing JSON output
# n is a numeric literal or 'n|N', meaning "at least one, but maybe more"
# req=False means the argument need not be present in the list
# helptext is the associated help for the command
# anything else are arguments to pass to the type constructor.
# self.instance is an instance of type t constructed with typeargs.
# valid() will later be called with input to validate against it,
# and will store the validated value in self.instance.val for extraction.

class argdesc(object):
    def __init__(self, t, name=None, n=1, req=True, **kwargs):
        if isinstance(t, types.StringTypes):
            self.t = CephPrefix
            self.typeargs = {'prefix':t}
            self.req = True
        else:
            self.t = t
            self.typeargs = kwargs
            self.req = bool(req == True or req == 'True')

        self.name = name
        self.N = (n in ['n', 'N'])
        if self.N:
            self.n = 1
        else:
            self.n = int(n)
        self.instance = self.t(**self.typeargs)

    def __repr__(self):
        r = 'argdesc(' + str(self.t) + ', '
        internals = ['N', 'typeargs', 'instance', 't']
        for (k,v) in self.__dict__.iteritems():
            if k.startswith('__') or k in internals:
                pass
            else:
                # undo mods above
                if k == 'n' and self.N:
                    v = 'N'
                r += '{}={}, '.format(k,v)
        for (k,v) in self.typeargs.iteritems():
                r += '{}={}, '.format(k,v)
        return r[:-2] + ')'

    def __str__(self):
        if ((self.t == CephChoices and len(self.instance.strings) == 1)
            or (self.t == CephPrefix)):
            s = '{}'.format(str(self.instance))
        else:
            s = '{}({})'.format(self.name, str(self.instance))
            if self.N:
                s += '[' + str(self.instance) + '...]'
        if not self.req:
            s = '{' + s + '}'
        return s

    # like above, but omit parameter names
    def helpstr(self):
        s = '{}'.format(str(self.instance))
        if self.N:
            s += '[' + str(self.instance) + '...]'
        if not self.req:
            s = '{' + s + '}'
        return s

def concise_sig(sig):
    first = True
    s = ''
    for d in sig:
        if first:
            first = False
        else:
            s += ' '
        s += d.helpstr()
    return s

"""
parse_json_funcsigs(s)

A function signature is mostly an array of argdesc; it's represented
in JSON as 
{ 
  "cmd1": {"sig":[ "type": type, "name": name, "n": num, "req":true|false <other param>], "help:{"help":helptext}
   .
   .
   .
  ]

A set of sigs is in an dict mapped by a unique number:
{
  "cmd1": {
     "sig": ["type.. ], "help":{"text":helptext}
  }
  "cmd2"{
     "sig": [.. ], "help":{"text":helptext}
  }
}

Parse the string s and return an dict of dicts, keyed by opcode;
each dict contains 'sig' with the array of descriptors, and 'help'
with the helptext.
"""


def parse_json_funcsig(s):
    try:
        overall = json.loads(s)
    except Exception as e:
        print >> sys.stderr, "Couldn't parse JSON {}: {}".format(s, e)
        raise e
    sigdict = {}
    for cmdtag, sigandhelp in overall.iteritems():
        helptext = sigandhelp.get('help', 'no help available')
        try:
            sig = sigandhelp['sig']
        except KeyError:
            s = "JSON descriptor {} has no 'sig'".format(cmdtag)
            raise JsonFormat(s)

        newsig = []
        argnum = 0
        for desc in sig:
            argnum += 1
            if isinstance(desc, types.StringTypes):
                t = CephPrefix
                desc = {'type':t, 'name':'prefix', 'prefix':desc}
            else:
                # not a simple string, must be dict
                if not 'type' in desc:
                    s = 'JSON descriptor {} has no type'.format(sig)
                    raise JsonFormat(s)
                # look up type string in our globals() dict; if it's an
                # object of type types.TypeType, it must be a
                # locally-defined class. otherwise, we haven't a clue.
                if desc['type'] in globals():
                    t = globals()[desc['type']]
                    if type(t) != types.TypeType:
                        s = 'unknown type {}'.format(desc['type'])
                        raise JsonFormat(s)
                else:
                    s = 'unknown type {}'.format(desc['type'])
                    raise JsonFormat(s)

            kwargs = dict()
            for key, val in desc.items():
                if key not in ['type', 'name', 'n', 'req']:
                    kwargs[key] = val
            newsig.append(argdesc(t,
                                  name=desc.get('name', None),
                                  n=desc.get('n', 1),
                                  req=desc.get('req', True),
                                  **kwargs))
        sigdict[cmdtag] = {'sig':newsig, 'helptext':helptext}
    return sigdict

"""
validate_one(word, desc, partial=False)

Return true if word matches desc (or partially, if partial == True).
Raise exception if not.
"""
def validate_one(word, desc, partial=False):
    # validate word against the constructed instance of the type
    # in desc.  May raise exception.  If it returns false (and doesn't
    # raise an exception), desc.instance.val will
    # contain the validated value (in the appropriate type).
    if desc.instance.valid(word, partial):
        desc.numseen += 1
        if desc.N:
            desc.n = desc.numseen + 1
        return True
    return False

"""
matchnum(s, signature, partial=False)

Returns number of arguments matched in s against signature.
Can be used to determine most-likely command for full or partial
matches (partial applies to string matches).
"""

def matchnum(args, signature, partial=False):
    words = args[:]
    mysig = copy.deepcopy(signature)
    matched = 0
    for desc in mysig:
        setattr(desc, 'numseen', 0)
        while desc.numseen < desc.n:
            try:
                word = words.pop(0)
            except:
                # regardless, return how many we matched
                return matched
            # may raise exception
            try:
                validate_one(word, desc, partial)
            except:
                return matched
        matched += 1
    return matched

"""
validate(s, signature)

Assumes s represents a possible command input following format of
signature.  Runs a validation; no exception means it's OK.  Return
a dict containing all arguments named by their descriptor name
(with duplicate args per name accumulated into a space-separated
value).
"""

def validate(args, signature):
    words = args[:]
    mysig = copy.deepcopy(signature)
    argpos = 1
    d = dict()
    for desc in mysig:
        setattr(desc, 'numseen', 0)
        while desc.numseen < desc.n:
            try:
                word = words.pop(0)
            except:
                if desc.req:
                    if desc.N and desc.numseen < 1:
                        raise ArgumentNumber('saw {} of {}, expected at least 1'.format(desc.numseen, desc))
                    elif not desc.N and desc.numseen < desc.n:
                        raise ArgumentNumber('saw {} of {}, expected {}'.format(desc.numseen, desc, desc.n))
                break
            # may raise exception
            validate_one(word, desc)

            if desc.name in d:
                d[desc.name] += [desc.instance.val]
            else:
                d[desc.name] = [desc.instance.val]
        argpos += 1
    # print "validate returning", d
    return d

# convenience function for testing

def try_validate(s, sig):
    try:
        dump = validate(s, sig)
        print '{!r} ok against {}'.format(s, sig)
        print dump
    except Exception as e:
        print '{!r} failed: {}'.format(s, e)
    print

def parse_cmdargs(usage=''):
    parser = argparse.ArgumentParser(description='Frontend for ceph CLI',
                                     usage=usage)
    parser.add_argument('-c', dest='cephconf',
                        help='ceph configuration file')
    parser.add_argument('-i', '--in-file', dest='input_file',
                        help='input file')
    parser.add_argument('-o', '--out-file', dest='output_file',
                        help='output file')
    parser.add_argument('-k', '--keyring', dest='keyring_file',
                        help='keyring file')
    parser.add_argument('--admin-daemon', dest='admin_socket',
                        help='submit admin-socket commands (\"help\" for help')
    parser.add_argument('-s', '--status', action='store_true', help='show cluster status')
    parser.add_argument('-w', '--watch', action='store_true', help='watch live cluster changes')
    parser.add_argument('--watch-debug', action='store_true',
                        help='watch debug events')
    parser.add_argument('--watch-info', action='store_true',
                        help='watch info events')
    parser.add_argument('--watch-sec', action='store_true',
                        help='watch sec events')
    parser.add_argument('--watch-warn', action='store_true',
                        help='watch warn events')
    parser.add_argument('--watch-error', action='store_true',
                        help='watch error events')
    parser.add_argument('-v', '--verbose', action="store_true")
    parser.add_argument('--concise')
    parser.add_argument('-f', '--format', choices=['json', 'xml', 'plain'], dest='output_format')
    # returns a Namespace with the parsed args, and a list of all extras
    return parser.parse_known_args()

def get_process_output(args):
    p = subprocess.Popen(args, stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    outdata, errdata = p.communicate()
    if (len(errdata)):
        print "error: ", errdata
        sys.exit(1)
    return outdata

def do_command(command, d, verbose=False, endless=False):

    def make_nonblocking(filelist):
        for f in filelist:
            flags = fcntl.fcntl(f, fcntl.F_GETFL)
            fcntl.fcntl(f, fcntl.F_SETFL, flags | os.O_NONBLOCK)

    command.append(json.dumps(d))
    if verbose:
        print >> sys.stderr, "invoking ", command
    p = subprocess.Popen(command, stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    if endless:
        try:
            make_nonblocking([p.stdout, p.stderr])
            fdlist = [p.stdout.fileno(), p.stderr.fileno()]
            while not p.poll():
                (r, _, e) = select.select(fdlist, [], fdlist, 1)
                if (p.stdout.fileno() in r):
                    print p.stdout.read()
                if (p.stderr.fileno() in r):
                    print >> sys.stderr, p.stderr.read()
                if e:
                    print >> sys.stderr, "error on process stdout/stderr"
        except KeyboardInterrupt:
            pass

    else:
        outdata, errdata = p.communicate()
        if len(errdata):
            print >> sys.stderr, errdata
        print outdata
    return p.returncode

def main():
    #global cluster
    #cluster = rados.Rados(conffile='')

    command = os.environ.get('COMMAND')
    if not command:
        command = "./cephbin"
    command = [command]

    # fetch JSON sigs from command
    # each line contains one command signature (a placeholder name
    # of the form 'cmdNNN' followed by an array of argument descriptors)
    # as part of the validated argument JSON object

    outdata = get_process_output(command + ['get_command_descriptions'])
    sigdict = parse_json_funcsig(outdata.strip())

    fullusage = ''
    for op, sigandhelp in sigdict.iteritems():
        fullusage += '{}: {}\n'.format(concise_sig(sigandhelp['sig']),
                                       sigandhelp['helptext'])
    parsed_args, childargs = parse_cmdargs()

    verbose = parsed_args.verbose
    if verbose:
        for cmdtag in sorted(sigdict.keys()):
            sigandhelp = sigdict[cmdtag]
            sig = sigandhelp['sig']
            print '{}: {}'.format(cmdtag, concise_sig(sig))

    # special commands: '-s' is its own command
    got_command = False
    endless = False
    if parsed_args.status:
        command.append('-s')
        got_command = True

    # -w/--watch* are also their own endless monitoring commands

    # this is ugly, but Namespace() isn't quite rich enough
    for k,v in parsed_args._get_kwargs():
        if k.startswith('watch') and v:
            arg = '--' + k.replace('_', '-')
            command.append(arg)
            endless = True;
            got_command = True

    # just pass on -i, -o, -k
    if parsed_args.input_file:
        command.extend(['-i', parsed_args.input_file])
    if parsed_args.output_file:
        command.extend(['-o', parsed_args.output_file])
    if parsed_args.keyring_file:
        command.extend(['-k', parsed_args.keyring_file])

    if parsed_args.admin_socket:
        command.extend(['--admin-daemon', parsed_args.admin_socket] + childargs)
        got_command = True

    # validate input args against list of sigs

    found = None
    valid_dict = {}
    if childargs:
        # look for best match, accumulate possibles in bestsigs
        # (so we can maybe give a more-useful error message)
        best_match_cnt = 0
        bestsigs = []
        for op, sigandhelp in sigdict.iteritems():
            sig = sigandhelp['sig']
            matched = matchnum(childargs, sig, partial=True)
            if (matched > best_match_cnt):
                if verbose:
                    print >> sys.stderr, \
                        "better match: {} > {}:{} ".format(matched,
                                                           best_match_cnt, sig)
                best_match_cnt = matched
                bestsigs = [{op:sigandhelp}]
            elif matched == best_match_cnt:
                if verbose:
                    print >> sys.stderr, \
                        "equal match: {} > {}:{} ".format(matched,
                                                           best_match_cnt, sig)
                bestsigs.append({op:sigandhelp})

        if verbose:
            print >> sys.stderr, "bestsigs: ", bestsigs

        # for everything in bestsigs, look for a true match
        for cmdsig in bestsigs:
            for (cmdtag, sigandhelp) in cmdsig.iteritems():
                sig = sigandhelp['sig']
                helptext = sigandhelp['helptext']
                try:
                    valid_dict = validate(childargs, sig)
                    found = sig
                    break
                except ArgumentPrefix:
                    # this is common, and we don't want to whine about it
                    pass
                except ArgumentError as e:
                    print >> sys.stderr, '{}: invalid command'.\
                        format(' '.join(childargs))
                    print >> sys.stderr, '{}'.format(e)
                    print >> sys.stderr, "did you mean {}?\n\t{}".\
                        format(concise_sig(sig), helptext)
                    pass

    # special case: combine prefix into a single string 
    if 'prefix' in valid_dict:
        valid_dict['prefix'] = ' '.join(valid_dict['prefix'])

    # translate any single-item lists into simple values
    for key, val in valid_dict.iteritems():
        if isinstance(val, types.ListType) and len(val) == 1:
            valid_dict[key] = val[0]

    if not (found or got_command):
        return 1

    if parsed_args.output_format:
        valid_dict['format'] = parsed_args.output_format
    sys.exit(do_command(command, valid_dict, verbose, endless))

###
# main
###

if __name__ == '__main__':
    sys.exit(main())





# obsolete interfaces; should recode

def selftest():
    sig = [argdesc('osd'), argdesc('stat')]
    print sig
    for c in ['osd stat', 'osd foo']:
        try_validate(c, sig)
    sig = [argdesc('osd'), argdesc('find'),
           argdesc(CephInt, name='n', req=True)]
    for c in ['osd find s', 'osd find', 'osd find 1']:
        try_validate(c, sig)
    sig = [argdesc(CephInt, name='ids', req=True, n='N')]
    print sig
    try_validate('0 1 2' , sig)
    print sig
    try_validate('0 1 2 s' , sig)

    sig = parse_json_funcsig('{"signame":"mylittlesiggy", "sig":[{"type":"literal", "name":"arg1", "req":false}]}')
    try_validate('literal', sig)
    try_validate('iteral', sig)
    sig = parse_json_funcsig('{"signame":"mybigsiggy", "sig":[{"type":"CephInt", "name":"arg1", "req":false}]}')
    try_validate('1', sig)
    try_validate('', sig)
    try_validate('s', sig)

    sigs = [
        [argdesc('osd'), argdesc('crush'), argdesc('tunables'),
         argdesc(CephChoices,
                 strings='legacy|argonaut|bobtail|optimal|default')],
        [argdesc('mon'), argdesc('stat')],
        [argdesc('mon'), argdesc('getmap')],
        [argdesc('mon'), argdesc('dump')],
        [argdesc('mon'), argdesc('add'),
         argdesc(CephName, name="name", req=True), argdesc(CephIPAddr, name="addr", req=True)],
        [argdesc('mon'), argdesc('remove'), argdesc(CephName)]
    ]

    try_validate("osd crush tunables foo", sigs[0])
    try_validate("osd crush tunables legacy", sigs[0])
    try_validate("mon stat", sigs[1])
    try_validate("mon add mon.a 10.1.1.4", sigs[4])
    try_validate("mon add mon.a 10.1.1.4:1000", sigs[4])
    try_validate("mon add mon.a ffe0::0", sigs[4])
    try_validate("mon add mon.a [ffe0::0]:6789", sigs[4])

    intsig = [argdesc(CephInt, range=[0,15])]
    try_validate('-1', intsig)
    try_validate('0', intsig)
    try_validate('1', intsig)
    try_validate('15', intsig)
    try_validate('16', intsig)
    intsig = [argdesc(CephInt, range=[-128, 127])]
    try_validate('0', intsig)
    try_validate('-1', intsig)
    try_validate('-128', intsig)
    try_validate('-129', intsig)
    try_validate('127', intsig)
    try_validate('128', intsig)
    try_validate('255', intsig)
    try_validate('256', intsig)

    floatsig = [argdesc(CephFloat, range=[0.0, 1.0])]
    try_validate('1.0', floatsig)
    try_validate('1.000001', floatsig)
    try_validate('0.0', floatsig)
    try_validate('-0.0', floatsig)
    try_validate('-0.0000001', floatsig)

