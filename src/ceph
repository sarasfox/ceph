#!/usr/bin/python

import sys
import os
import stat
#import rados
import json
import copy
import types
import subprocess
import socket
import uuid
import argparse
import select
import fcntl
import string
import readline

verbose = False

"""
Something wrong with arguments
"""
class ArgumentError(Exception):
    pass

"""
Wrong number of a repeated argument
"""
class ArgumentNumber(ArgumentError):
    pass

"""
Argument value has wrong format 
"""
class ArgumentFormat(ArgumentError):
    pass

"""
Argument value is otherwise invalid (doesn't match choices, for instance)
"""
class ArgumentValid(ArgumentError):
    pass

"""
Special for mismatched prefix; less severe, don't report by default
"""
class ArgumentPrefix(ArgumentError):
    pass

"""
some semantic issue with the JSON
"""
class JsonFormat(Exception):
    pass

"""
Base class for all Ceph argument types

Instantiating an object sets any validation parameters 
(allowable strings, numeric ranges, etc.).  The 'valid'
method validates a string against that initialized instance,
throwing ArgumentError if there's a problem.
"""
class CephArgtype(object):
    def __init__(self, **kwargs):
        """
        set any per-instance validation parameters here 
        from kwargs (fixed string sets, integer ranges, etc)
        """
        pass

    def valid(self, s, partial=False):
        """
        Run validation against given string s (generally one word);
        partial means to accept partial string matches (begins-with).
        If cool, set self.val to the value that should be returned
        (a copy of the input string, or a numeric or boolean interpretation
        thereof, for example), and return True
        if not, throw ArgumentError(msg-as-to-why)
        """
        pass

    def __repr__(self):
        """
        return string representation of description of type.  Note,
        this is not a representation of the actual value.  Subclasses
        probably also override __str__() to give a more user-friendly
        'name/type' description for use in command format help messages.
        """
        a = ''
        if hasattr(self, 'typeargs'):
            a = self.typeargs
        return '{}(\'{}\')'.format(self.__class__.__name__, a)

    def __str__(self):
        """
        where __repr__ (ideally) returns a string that could be used to
        reproduce the object, __str__ returns one you'd like to see in
        print messages.  Use __str__ to format the argtype descriptor
        as it would be useful in a command usage message.
        """
        return '<{}>'.format(self.__class__.__name__)

"""
range-limited integers, [+|-][0-9]+ or 0x[0-9a-f]+
range: list of 1 or 2 ints, [min] or [min,max]
"""
class CephInt(CephArgtype):
    def __init__(self, range=''):
        if range == '':
            self.range = list()
        else:
            self.range = list(range.split('|'))
            self.range = map(long, self.range)

    def valid(self, s, partial=False):
        try:
            val = long(s)
        except ValueError:
            raise ArgumentValid("{} doesn't represent an int".format(s))
        if len(self.range) == 2:
            if val < self.range[0] or val > self.range[1]:
                raise ArgumentValid("{} not in range {}".format(val, self.range))
        elif len(self.range) == 1:
            if val < self.range[0]:
                raise ArgumentValid("{} not in range {}".format(val, self.range))
        self.val = val
        return True

    def __str__(self):
        r = ''
        if len(self.range) == 1:
            r = '[{}-]'.format(self.range[0])
        if len(self.range) == 2:
            r = '[{}-{}]'.format(self.range[0], self.range[1])

        return '<int{}>'.format(r)


"""
range-limited float type
range: list of 1 or 2 floats, [min] or [min, max]
"""
class CephFloat(CephArgtype):
    def __init__(self, range=''):
        if range == '':
            self.range = list()
        else:
            self.range = list(range.split('|'))
            self.range = map(float, self.range)

    def valid(self, s, partial=False):
        try:
            val = float(s)
        except ValueError:
            raise ArgumentValid("{} doesn't represent a float".format(s))
        if len(self.range) == 2:
            if val < self.range[0] or val > self.range[1]:
                raise ArgumentValid("{} not in range {}".format(val, self.range))
        elif len(self.range) == 1:
            if val < self.range[0]:
                raise ArgumentValid("{} not in range {}".format(val, self.range))
        self.val = val
        return True

    def __str__(self):
        r = ''
        if len(self.range) == 1:
            r = '[{}-]'.format(self.range[0])
        if len(self.range) == 2:
            r = '[{}-{}]'.format(self.range[0], self.range[1])
        return '<float{}>'.format(r)

"""
String.  Not much use for this; maybe we might use illegal chars
for something?
"""
class CephString(CephArgtype):
    def __init__(self, badchars=''):
        self.badchars = badchars

    def valid(self, s, partial=False):
        for c in self.badchars:
            if c in s:
                raise ArgumentFormat("bad char {} in {}".format(c, s))
        self.val = s
        return True

    def __str__(self):
        b = ''
        if len(self.badchars):
            b = '(without chars in {})'.format(self.badchars)
        return '<string{}>'.format(b)

"""
Admin socket path; check that it's readable and S_ISSOCK
"""
class CephSocketpath(CephArgtype):
    def valid(self, s, partial=False):
        mode = os.stat(s).st_mode
        if not stat.S_ISSOCK(mode):
            raise ArgumentValid('socket path {} is not a socket'.format(s))
        self.val = s
        return True
    def __str__(self):
        return '<admin-socket-path>'

"""
IP address (v4 or v6) with optional port
"""
class CephIPAddr(CephArgtype):
    def valid(self, s, partial=False):
        # parse off port, use socket to validate addr
        type = 6
        if s.startswith('['):
            type = 6
        elif s.find('.') != -1:
            type = 4
        if type == 4:
            port = s.find(':')
            if (port != -1):
                a = s[:port]
                p = s[port+1:]
                if int(p) > 65535:
                    raise ArgumentValid('{}: invalid IPv4 port'.format(p))
            else:
                a = s
                p = None
            try:
                socket.inet_pton(socket.AF_INET, a)
            except:
                raise ArgumentValid('{}: invalid IPv4 address'.format(a))
        else:
            # v6
            if s.startswith('['):
                end = s.find(']')
                if end == -1:
                    raise ArgumentFormat('{} missing terminating ]'.format(s))
                if s[end+1] == ':':
                    try:
                        p = int(s[end+2])
                    except:
                        raise ArgumentValid('{}: bad port number'.format(s))
                a = s[1:end]
            else:
                a = s
                p = None
            try:
                socket.inet_pton(socket.AF_INET6, a)
            except:
                raise ArgumentValid('{} not valid IPv6 address'.format(s))
        if p is not None and long(p) > 65535:
            raise ArgumentValid("{} not a valid port number".format(p))
        self.val = s
        return True

    def __str__(self):
        return '<IPaddr[:port]>' 

class CephEntityAddr(CephIPAddr):
    def valid(self, s, partial=False):
        ip, nonce = s.split('/')
        if not super(CephIPAddr, self).valid(self, ip):
            raise ArgumentValid('CephEntityAddr {}: ip address invalid'.format(s))
        self.val = s
        return True

    def __str__(self):
        return '<EntityAddr>'

"""
Pool name; checked for presence in cluster
"""
class CephPoolname(CephArgtype):
    def valid(self, s, partial=False):
        # XXX 
        # if cluster.pool.exists(s):
        #    raise ArgumentValid("pool {} does not exist".format(s))
        self.val = s
        return True

    def __str__(self):
        return '<poolname>'

"""
Object name.  Maybe should be combined with Pool name as they're always
present in pairs, and then could be checked for presence
"""
class CephObjectname(CephArgtype):
    def valid(self, s, partial=False):
        self.val = s
        return True

    def __str__(self):
        return '<objectname>'

"""
pgid, in form N.xxx (N = pool number, xxx = hex pgnum)
"""
class CephPgid(CephArgtype):
    def valid(self, s, partial=False):
        if s.find('.') == -1:
            raise ArgumentFormat('pgid has no .')
        poolid, pgnum = s.split('.')
        if poolid < 0:
            raise ArgumentFormat('pool {} < 0'.format(poolid))
        try:
            pgnum = int(pgnum, 16)
        except:
            raise ArgumentFormat('pgnum {} not hex integer'.format(pgnum))
        self.val = s
        return True

    def __str__(self):
        return '<pgid>'

"""
Name, or type.id, where type is osd|mon|client|mds, and id is a base10 int.
Also accept '*'
"""
class CephName(CephArgtype):
    def valid(self, s, partial=False):
        if s == '*':
            self.val = s
            return True
        if s.find('.') == -1:
            raise ArgumentFormat('no .')
        t, i = s.split('.')
        if not t in ('osd', 'mon', 'client', 'mds'):
            raise ArgumentValid('unknown type ' + self.t)
        if t == 'osd':
            try:
                i = int(i)
            except:
                raise ArgumentFormat('osd id ' + i + ' not integer')
            # could check for valid id?
        self.val = s
        return True

    def __str__(self):
        return '<name (type.id)>'

"""
Set of string literals; init with valid choices
"""

class CephChoices(CephArgtype):
    def __init__(self, strings='', **kwargs):
        self.strings=strings.split('|')

    def valid(self, s, partial=False):
        if not partial:
            if not s in self.strings:
                # show as __str__ does: {s1|s2..}
                raise ArgumentValid("{} not in {}".format(s, self))
            self.val = s
            return True

        # partial
        for t in self.strings:
            if t.startswith(s):
                self.val = s
                return True
        raise ArgumentValid("{} not in {}".  format(s, self))

    def __str__(self):
        if len(self.strings) == 1:
            return '{}'.format(self.strings[0])
        else:
            return '{{{}}}'.format('|'.join(self.strings))

"""
Openable file
"""
class CephFilepath(CephArgtype):
    def valid(self, s, partial=False):
        try:
            open(s, 'a+')
        except Exception as e:
            raise ArgumentValid('can\'t open {}: {}'.format(s, e))
        self.val = s
        return True

    def __str__(self):
        return '<outfilename>'

"""
'Fragment' ??? XXX
"""
class CephFragment(CephArgtype):
    def valid(self, s, partial=False):
        if s.find('/') == -1:
            raise ArgumentFormat('{}: no /'.format(s))
        val, bits = s.split('/')
        # XXX is this right?
        if not val.startswith('0x'):
            raise ArgumentFormat("{} not a hex integer".format(val))
        try:
            long(val)
        except:
            raise ArgumentFormat('can\'t convert {} to integer'.format(val))
        try:
            long(bits)
        except:
            raise ArgumentFormat('can\'t convert {} to integer'.format(bits))
        self.val = s
        return True

    def __str__(self):
        return "<CephFS fragment ID (0xvvv/bbb)>"


""" 
CephUUID: pretty self-explanatory
"""
class CephUUID(CephArgtype):
    def valid(self, s, partial=False):
        try:
            uuid.UUID(s)
        except Exception as e:
            raise ArgumentFormat('invalid UUID {}: {}'.format(s, e))
        self.val = s
        return True

    def __str__(self):
        return '<uuid>'

"""
CephPrefix: magic type for "all the first n fixed strings"
"""
class CephPrefix(CephArgtype):
    def __init__(self, prefix=''):
        self.prefix = prefix

    def valid(self, s, partial=False):
        if partial:
            if self.prefix.startswith(s):
                self.val = s
                return True
        else:
            if (s == self.prefix):
                self.val = s
                return True
        raise ArgumentPrefix("no match for {}".format(s))

    def __str__(self):
        return self.prefix

############################################################################

# argdesc(typename, [type-specific kwargs], name='name', n=numallowed, req=False, helptext=helptext, **kwargs)
# validation rules:
# typename: type(**kwargs) will be constructed
# later, type.valid(w) will be called with a word in that position
# name is used for parse errors and for constructing JSON output
# n is a numeric literal or 'n|N', meaning "at least one, but maybe more"
# req=False means the argument need not be present in the list
# helptext is the associated help for the command
# anything else are arguments to pass to the type constructor.
# self.instance is an instance of type t constructed with typeargs.
# valid() will later be called with input to validate against it,
# and will store the validated value in self.instance.val for extraction.

class argdesc(object):
    def __init__(self, t, name=None, n=1, req=True, **kwargs):
        if isinstance(t, types.StringTypes):
            self.t = CephPrefix
            self.typeargs = {'prefix':t}
            self.req = True
        else:
            self.t = t
            self.typeargs = kwargs
            self.req = bool(req == True or req == 'True')

        self.name = name
        self.N = (n in ['n', 'N'])
        if self.N:
            self.n = 1
        else:
            self.n = int(n)
        self.instance = self.t(**self.typeargs)

    def __repr__(self):
        r = 'argdesc(' + str(self.t) + ', '
        internals = ['N', 'typeargs', 'instance', 't']
        for (k,v) in self.__dict__.iteritems():
            if k.startswith('__') or k in internals:
                pass
            else:
                # undo mods above
                if k == 'n' and self.N:
                    v = 'N'
                r += '{}={}, '.format(k,v)
        for (k,v) in self.typeargs.iteritems():
                r += '{}={}, '.format(k,v)
        return r[:-2] + ')'

    def __str__(self):
        if ((self.t == CephChoices and len(self.instance.strings) == 1)
            or (self.t == CephPrefix)):
            s = '{}'.format(str(self.instance))
        else:
            s = '{}({})'.format(self.name, str(self.instance))
            if self.N:
                s += '[' + str(self.instance) + '...]'
        if not self.req:
            s = '{' + s + '}'
        return s

    # like above, but omit parameter names
    def helpstr(self):
        s = '{}'.format(str(self.instance))
        if self.N:
            s += '[' + str(self.instance) + '...]'
        if not self.req:
            s = '{' + s + '}'
        return s

def concise_sig(sig):
    first = True
    s = ''
    for d in sig:
        if first:
            first = False
        else:
            s += ' '
        s += d.helpstr()
    return s

"""
parse_json_funcsigs(s)

A function signature is mostly an array of argdesc; it's represented
in JSON as 
{ 
  "cmd1": {"sig":[ "type": type, "name": name, "n": num, "req":true|false <other param>], "help:{"help":helptext}
   .
   .
   .
  ]

A set of sigs is in an dict mapped by a unique number:
{
  "cmd1": {
     "sig": ["type.. ], "help":{"text":helptext}
  }
  "cmd2"{
     "sig": [.. ], "help":{"text":helptext}
  }
}

Parse the string s and return an dict of dicts, keyed by opcode;
each dict contains 'sig' with the array of descriptors, and 'help'
with the helptext.
"""


def parse_json_funcsig(s):
    try:
        overall = json.loads(s)
    except Exception as e:
        print >> sys.stderr, "Couldn't parse JSON {}: {}".format(s, e)
        raise e
    sigdict = {}
    for cmdtag, cmd in overall.iteritems():
        helptext = cmd.get('help', 'no help available')
        try:
            sig = cmd['sig']
        except KeyError:
            s = "JSON descriptor {} has no 'sig'".format(cmdtag)
            raise JsonFormat(s)

        newsig = []
        argnum = 0
        for desc in sig:
            argnum += 1
            if isinstance(desc, types.StringTypes):
                t = CephPrefix
                desc = {'type':t, 'name':'prefix', 'prefix':desc}
            else:
                # not a simple string, must be dict
                if not 'type' in desc:
                    s = 'JSON descriptor {} has no type'.format(sig)
                    raise JsonFormat(s)
                # look up type string in our globals() dict; if it's an
                # object of type types.TypeType, it must be a
                # locally-defined class. otherwise, we haven't a clue.
                if desc['type'] in globals():
                    t = globals()[desc['type']]
                    if type(t) != types.TypeType:
                        s = 'unknown type {}'.format(desc['type'])
                        raise JsonFormat(s)
                else:
                    s = 'unknown type {}'.format(desc['type'])
                    raise JsonFormat(s)

            kwargs = dict()
            for key, val in desc.items():
                if key not in ['type', 'name', 'n', 'req']:
                    kwargs[key] = val
            newsig.append(argdesc(t,
                                  name=desc.get('name', None),
                                  n=desc.get('n', 1),
                                  req=desc.get('req', True),
                                  **kwargs))
        sigdict[cmdtag] = {'sig':newsig, 'helptext':helptext}
    return sigdict

"""
validate_one(word, desc, partial=False)

Return true if word matches desc (or partially, if partial == True).
Raise exception if not.
"""
def validate_one(word, desc, partial=False):
    # validate word against the constructed instance of the type
    # in desc.  May raise exception.  If it returns false (and doesn't
    # raise an exception), desc.instance.val will
    # contain the validated value (in the appropriate type).
    if desc.instance.valid(word, partial):
        desc.numseen += 1
        if desc.N:
            desc.n = desc.numseen + 1
        return True
    return False

"""
matchnum(s, signature, partial=False)

Returns number of arguments matched in s against signature.
Can be used to determine most-likely command for full or partial
matches (partial applies to string matches).
"""

def matchnum(args, signature, partial=False):
    words = args[:]
    mysig = copy.deepcopy(signature)
    matchcnt = 0
    for desc in mysig:
        setattr(desc, 'numseen', 0)
        while desc.numseen < desc.n:
            if not words:
                return matchcnt;
            word = words.pop(0)
            # may raise exception
            try:
                validate_one(word, desc, partial)
            except:
                if not desc.req:
                    words.insert(0, word)
                    break
                else:
                    return matchcnt
        if desc.req:
            matchcnt += 1
    return matchcnt

"""
validate(s, signature)

Assumes s represents a possible command input following format of
signature.  Runs a validation; no exception means it's OK.  Return
a dict containing all arguments named by their descriptor name
(with duplicate args per name accumulated into a space-separated
value).
"""

def validate(args, signature):
    words = args[:]
    mysig = copy.deepcopy(signature)
    d = dict()
    for desc in mysig:
        setattr(desc, 'numseen', 0)
        while desc.numseen < desc.n:
            if words:
                word = words.pop(0)
            else:
                if desc.req:
                    if desc.N and desc.numseen < 1:
                        raise ArgumentNumber('saw {} of {}, expected at least 1'.format(desc.numseen, desc))
                    elif not desc.N and desc.numseen < desc.n:
                        raise ArgumentNumber('saw {} of {}, expected {}'.format(desc.numseen, desc, desc.n))
                break
            try:
                validate_one(word, desc)
            except Exception as e:
                if not desc.req:
                    words.insert(0, word)
                    break
                else:
                    raise e

            if desc.N:
                # value should be a list
                if desc.name in d:
                    d[desc.name] += [desc.instance.val]
                else:
                    d[desc.name] = [desc.instance.val]
            elif (desc.t == CephPrefix) and (desc.name in d):
                # value should be a space-joined concatenation
                d[desc.name] += ' ' + desc.instance.val
            else:
                # if first CephPrefix or any other type, just set it
                d[desc.name] = desc.instance.val
    return d

def parse_cmdargs(args=None, usage='', epilog='', add_help=True):
    # alias: let the line-wrapping be sane
    AP = argparse.ArgumentParser
    # formatter_class: don't linewrap epilog (our custom-formatted help)
    parser = AP(description='Frontend for ceph CLI', usage=usage,
                epilog=epilog, add_help=add_help,
                formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('-c', dest='cephconf',
                        help='ceph configuration file')
    parser.add_argument('-i', '--in-file', dest='input_file',
                        help='input file')
    parser.add_argument('--id', dest='client_id',
                        help='client id for authentication')
    parser.add_argument('-o', '--out-file', dest='output_file',
                        help='output file')
    parser.add_argument('-k', '--keyring', dest='keyring_file',
                        help='keyring file')
    parser.add_argument('--admin-daemon', dest='admin_socket',
                        help='submit admin-socket commands (\"help\" for help')
    parser.add_argument('-s', '--status', action='store_true', help='show cluster status')
    parser.add_argument('-w', '--watch', action='store_true', help='watch live cluster changes')
    parser.add_argument('--watch-debug', action='store_true',
                        help='watch debug events')
    parser.add_argument('--watch-info', action='store_true',
                        help='watch info events')
    parser.add_argument('--watch-sec', action='store_true',
                        help='watch sec events')
    parser.add_argument('--watch-warn', action='store_true',
                        help='watch warn events')
    parser.add_argument('--watch-error', action='store_true',
                        help='watch error events')
    parser.add_argument('-v', '--verbose', action="store_true")
    parser.add_argument('--concise')
    parser.add_argument('-f', '--format', choices=['json', 'json-pretty', 'xml', 'xml-pretty', 'plain'], dest='output_format')
    # for pg dump_stuck
    parser.add_argument('--threshold', type=int, help='number of seconds for a pg to be considered stuck for pg dump_stuck')
    # returns a Namespace with the parsed args, and a list of all extras
    return parser.parse_known_args(args)

def get_process_output(args):
    if verbose:
        print >> sys.stderr, "get_process_output({})".format(args)

    p = subprocess.Popen(args, stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    outdata, errdata = p.communicate()
    if (len(errdata)):
        print "error: ", errdata
    return outdata

def do_command(command, d, endless=False):

    def make_nonblocking(filelist):
        for f in filelist:
            flags = fcntl.fcntl(f, fcntl.F_GETFL)
            fcntl.fcntl(f, fcntl.F_SETFL, flags | os.O_NONBLOCK)

    full_command = command + [ json.dumps(d) ]
    if verbose:
        print >> sys.stderr, "invoking ", full_command
    p = subprocess.Popen(full_command, stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    if endless:
        try:
            make_nonblocking([p.stdout, p.stderr])
            fdlist = [p.stdout.fileno(), p.stderr.fileno()]
            while not p.poll():
                (r, _, e) = select.select(fdlist, [], fdlist, 1)
                if (p.stdout.fileno() in r):
                    print p.stdout.read()
                if (p.stderr.fileno() in r):
                    print >> sys.stderr, p.stderr.read()
                if e:
                    print >> sys.stderr, "error on process stdout/stderr"
        except KeyboardInterrupt:
            p.terminate()
            pass

    else:
        outdata, errdata = p.communicate()
        if len(errdata):
            print >> sys.stderr, errdata
        print outdata
    return p.returncode

"""
sort descriptors by prefixes, defined as the concatenation of all simple
strings in the descriptor; this works out to just the leading strings.
"""
def descsort(sh1, sh2):
    return cmp(concise_sig(sh1['sig']), concise_sig(sh2['sig']))


"""
generator to transform s into a sequence of strings width or shorter,
for wrapping text to a specific column width.
Attempt to break on anything but dontsplit characters.
indent is amount to indent 2nd-through-nth lines.

so "long string long string long string" width=11 indent=1 becomes
'long string', ' long string', ' long string' so that it can be printed
as 
long string
 long string
 long string

Consumes s.
"""
dontsplit = string.letters + '{[<>]}'

def wrap(s, width, indent):
    result = ''
    leader = ''
    while len(s):

        if (len(s) <= width):
            # no splitting; just possibly indent
            result = leader + s
            s = ''
            yield result

        else:
            splitpos = width
            while (splitpos > 0) and (s[splitpos-1] in dontsplit):
                splitpos -= 1

            if splitpos == 0:
                splitpos = width

            if result:
                # prior result means we're mid-iteration, indent
                result = leader
            else:
                # first time, set leader and width for next
                leader = ' ' * indent
                width -= 1      # for subsequent space additions

            # remove any leading spaces in this chunk of s
            result += s[:splitpos].lstrip()
            s = s[splitpos:]

            yield result

    raise StopIteration

def format_help(cmddict):
    fullusage = ''
    for cmd in sorted(cmddict.itervalues(), cmp=descsort):

        siglines = [l for l in wrap(concise_sig(cmd['sig']), 40, 1)]
        helplines = [l for l in wrap(cmd['helptext'], 39, 1)]

        # make lists the same length
        maxlen = max(len(siglines), len(helplines))
        siglines.extend([''] * (maxlen - len(siglines)))
        helplines.extend([''] * (maxlen - len(helplines)))

        # so we can zip them for output
        for (s, h) in zip(siglines, helplines):
            fullusage += '{:40s} {}\n'.format(s, h)

    return fullusage

def validate_command(parsed_args, sigdict, args):
    """
    turn args into a valid dictionary ready to be sent off as JSON,
    validated against sigdict.
    parsed_args is the namespace back from argparse
    """
    found = []
    valid_dict = {}
    if args:
        # look for best match, accumulate possibles in bestsigs
        # (so we can maybe give a more-useful error message)
        best_match_cnt = 0
        bestsigs = []
        for cmdtag, cmd in sigdict.iteritems():
            sig = cmd['sig']
            matched = matchnum(args, sig, partial=True)
            if (matched > best_match_cnt):
                if verbose:
                    print >> sys.stderr, \
                        "better match: {} > {}:{}:{} ".format(matched,
                                      cmdtag, best_match_cnt, concise_sig(sig))
                best_match_cnt = matched
                bestsigs = [{cmdtag:cmd}]
            elif matched == best_match_cnt:
                if verbose:
                    print >> sys.stderr, \
                        "equal match: {} > {}:{}:{} ".format(matched,
                                      cmdtag, best_match_cnt, concise_sig(sig))
                bestsigs.append({cmdtag:cmd})

        if verbose:
            print >> sys.stderr, "bestsigs: ", bestsigs

        # for everything in bestsigs, look for a true match
        for cmdsig in bestsigs:
            for (cmdtag, cmd) in cmdsig.iteritems():
                sig = cmd['sig']
                helptext = cmd['helptext']
                try:
                    valid_dict = validate(args, sig)
                    found = sig
                    break
                except ArgumentPrefix:
                    # this means a CephPrefix type didn't match; since
                    # this is common, just eat it
                    pass
                except ArgumentError as e:
                    # prefixes matched, but some other arg didn't;
                    # this is interesting information
                    print >> sys.stderr, '{}: invalid command'.\
                        format(' '.join(args))
                    print >> sys.stderr, '{}'.format(e)
                    print >> sys.stderr, "did you mean {}?\n\t{}".\
                        format(concise_sig(sig), helptext)
                    pass

        if not found:
            print >> sys.stderr, 'no valid command found'
            print >> sys.stderr, 'close matches:'
            for cmdsig in bestsigs:
                for (cmdtag, cmd) in cmdsig.iteritems():
                    print >> sys.stderr, concise_sig(cmd['sig'])
            return None

        if parsed_args.output_format:
            valid_dict['format'] = parsed_args.output_format

        if parsed_args.threshold:
            valid_dict['threshold'] = parsed_args.threshold

        return valid_dict

def main():
    # XXX global cluster
    # XXX cluster = rados.Rados(conffile='')

    command = os.environ.get('COMMAND')
    if not command:
        command = "./cephbin"
    command = [command]

    # we have to parse twice, because we have to collect auth-related
    # options to be able to run the "get_command_descriptions" command.
    parsed_args, childargs = parse_cmdargs(add_help=False)

    global verbose
    verbose = parsed_args.verbose

    # pass on --id, -k, -c
    if parsed_args.client_id:
        command.extend(['--id', parsed_args.client_id])
    if parsed_args.keyring_file:
        command.extend(['-k', parsed_args.keyring_file])
    if parsed_args.cephconf:
        command.extend(['-c', parsed_args.cephconf])

    # fetch JSON sigs from command
    # each line contains one command signature (a placeholder name
    # of the form 'cmdNNN' followed by an array of argument descriptors)
    # as part of the validated argument JSON object

    sigdata = get_process_output(command + ['get_command_descriptions']).strip()
    sigdict = parse_json_funcsig(sigdata)

    parsed_args, childargs = parse_cmdargs(epilog='\nAvailable commands: \n\n'
                                           + format_help(sigdict))

    if verbose:
        for cmdtag in sorted(sigdict.keys()):
            cmd = sigdict[cmdtag]
            sig = cmd['sig']
            print '{}: {}'.format(cmdtag, concise_sig(sig))

    # Handle special command switches. 

    # -s behaves like a command (ceph status).  In fact
    # we *could* just do that here.
    got_command = False
    endless = False
    if parsed_args.status:
        command.append('-s')
        got_command = True

    # This is ugly, but Namespace() isn't quite rich enough.
    # Handle any --watch or -w command by marking endless,
    # passing on.
    for k,v in parsed_args._get_kwargs():
        if k.startswith('watch') and v:
            arg = '--' + k.replace('_', '-')
            command.append(arg)
            endless = True;
            got_command = True

    # Add on -i, -o if given
    if parsed_args.input_file:
        command.extend(['-i', parsed_args.input_file])
    if parsed_args.output_file:
        command.extend(['-o', parsed_args.output_file])

    # For now, --admin-daemon is handled as usual
    if parsed_args.admin_socket:
        command.extend(['--admin-daemon', parsed_args.admin_socket] + childargs)
        got_command = True

    if not got_command:
        if childargs:
            # Validate input args against list of sigs
            valid_dict = validate_command(parsed_args, sigdict, childargs)
            if valid_dict:
                return do_command(command, valid_dict, endless)
        else:
            while True:
                interactive_input = raw_input('ceph> ')
                if interactive_input in ['q', 'quit', 'Q']:
                    break
                childargs = parse_cmdargs(interactive_input.split())[1]
                valid_dict = validate_command(parsed_args, sigdict, childargs)
                if valid_dict:
                    do_command(command, valid_dict, endless)
                else:
                    print "invalid command"
    else:
        return do_command(command, None, endless)

###
# main
###

if __name__ == '__main__':
    sys.exit(main())
